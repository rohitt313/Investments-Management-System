# Investments-Management-System



## Objective
My program is trying to solve the problem of storing different investments such as stocks and Mutual Funds and maintaining an E-Portfolio for the user. My program allows the user to add new investments, buy more shares of an existing investment, sell partial/all shares of an investment, update the prices of all the investments, calculate the profit(getGain) that the user makes if all the investments are sold and search for investments based on different conditions. However, this program is more efficient than the previous version as first of all, I have created a super-class(abstract) called Investment and made Stock and MutualFund, its child classes and so they can inherit methods and variables from their parent class thus reducing code redundancy by appropriately implementing the concept of inheritance and polymorphism. Additionally, truly overridden methods have been added and the visibility of methods and variables have been adjusted accordingly to avoid privacy leak. Secondly, I have added a GUI interface which makes my program event-driven and allows for more than one event to be processed at the same time and does not have to wait for specific sequence of actions. Lastly, I have added exception handling so that the user is informed if they enter any kind of invalid data anywhere in the program, making my program more robust and user-friendly.


(3) To build my program, the user needs at least JDK version-17. To test my program, the user needs to first download the folder:rdalal_a3. Then the user needs to go to the directory - rdalal_a3 which contains the package - ePortfolio, Javadoc folder, README file and ePortfolio.jar. Then the user can simply enter the following command to compile the .java files in the package:
javac ePortfolio/Portfolio.java ePortfolio/Stock.java ePortfolio/MutualFund.java ePortfolio/Investment.java

To execute these files, the user can enter the following command:
java ePortfolio/Portfolio fileName.txt

If the user wants to run the program using the.jar file, then the command to run the .jar file is:
java -jar ePortfolio.jar fileName.txt

(4)
The package - ePortfolio contains an event-driven program where the user will be provided a drop-down Menu and 3 window control buttons: Minimize, Maximize and Close at the top of the window. However, the Close button will be disabled for the window so that the user does not accidentally close the window and lose the changes made to the Portfolio. The Main Menu has the following options:
(a)Buy - To buy a new investment or buy additional shares of an existing investment
(b)Sell - To sell all/partial shares of an existing investment 
(c)Update - To update the current price of an existing investment
(d)getGain - To see the total gain of the Portfolio if all the investments were to be sold as well as individual gain of each investment
(e)Search - To search an investment/investments based on Symbol, Name(Keywords) and price
(f)Quit - To terminate the program which will close the window and save the changes made to the Portfolio in a text file


The user will pass the name of the file as a command-line argument while executing the program at the very beginning. If the file name is not given, we print an appropriate message and simply terminate the program. The first time, the program is run the file does not exist and so we will get a FileNotFoundException and so we catch that exception and print that "Our Portfolio is currently empty" and if the program is terminated when the user quits the program, we write all the investments in our ArrayList to that text file.

Throughout the program we will be maintaining a HashMap which is of the format:<String,ArrayList<Integer>> where each keyword is represented by a string while the index/indices of that keyword(from the ArrayList) are represented by the ArrayList of Integers. When the program is executed, we will first load all the investments from the text file(if it exists) and add them to the ArrayList and use getName() method to extract each investment's name and tokenize it based on spaces to get keyword/KeyWords and then check whether that keyword exists in the HashMap as a key or not. If it does not exist, then we create a new ArrayList of indices and add its index position to it and then create a new Key,Value pair and add it to the HashMap. If that keyword exists in the HashMap, we then simply fetch the ArrayList of indices of that key and add the new index position and simply update that Key,Value pair entry in the HashMap.

Similarly, if we buy a new investment or sell an existing investment, we also change the contents of the HashMap with a method each for buying and selling(buyHashIndex() and sellHashIndex()). If we buy a new investment, we use getName() method to extract that investment's name and tokenize it based on spaces to get keyword/KeyWords and then check whether that keyword exists in the HashMap as a key or not. If it does not exist, then we create a new ArrayList of indices and add its index position to it and then create a new Key,Value pair and add it to the HashMap. If that keyword exists in the HashMap, we then simply fetch the ArrayList of indices of that key and add the new index position and simply update that Key,Value pair entry in the HashMap. If we are selling all the shares of an investment then before we remove that investment, we fetch each keyword and remove its respective index position from its indices ArrayList and if that ArrayList becomes empty then that means that keyword is not present in any investment's name and so we also remove that key,Value pair using the iterator's remove() method.

Investment class(abstract) has a constructor that has the following attributes: symbol,name,quantity,price and it does not have BookValue as an attribute as that will be calculated seperately for a Stock and MutualFund. So when buying a new Stock/MutualFund, we call its respective constructor and call the super constructor as the first statement and calculate the bookValue. When buying more shares of an existing Stock/MutualFund, we use Investment's get() methods to fetch the corresponding price, quantity and bookValue. Now since Investment class does not have a bookValue attribute,we check if the investment we are passing is an instance of Stock or MutualFund using "instanceof" and then typecast it to Stock/MutualFund and then fetch its bookValue and update the attributes along with the hashMap.

When selling an investment, the user can either sell partial or all the shares of an existing investment and since bookValue, gain, and payment are calculated differently for a Stock and MutualFund, Investment class has two abstract methods: remove() and sell() [to remove the investment and sell partial shares respectively] and these are overriden in Stock and MutualFund classes. If we are selling partial shares, we use the set() methods in the Investment class to change the attributes and again since it does not have an attribute called bookValue, we check if the investment we are passing is an instance of Stock or MutualFund using "instanceof" and then typecast it to Stock/MutualFund and then fetch its bookValue and update the attributes. If we are selling all the shares of that investment, then we simply remove that investment using the remove() method defined in Investment class.

When updating the prices of all the investments, we use the setPrice() methods defined in Investment class to change the price of each investment. When calculating the gain of the Portfolio, the calculateGain() method defined in Investment class is called which returns the total gain of the user(as a double value) if we were to sell all the investments.

Similarly, we also have methods that check the validity of symbol,price,quantity,priceRange and throw exceptions.

Further Explanation:

1. For the buy option, the user has to first select stock or mutualfund from the combo-box and then enter the symbol, name, quantity and price in their respective text fields. If any single field is left blank, then we print an appropriate message in its message area. We first, check if the user wants to buy a new investment(stock/mutualfund) and if we already have an investment(mutualfund/stock) with that symbol, then their request is rejected and we do not check for the remaining text fields. Next, we check if the entered price and quantity are valid, but this check is done in the constructor for Investment since when we create a new Stock/MutualFund object, they automatically invoke the super constructor. In Investment's constructor, we first check if they consist of digits, otherwise we throw an IllegalArgumentException. If it consists of digits but the value is less than 1, even then an IllegalArgumentException will be thrown. These exceptions will be caught by the buyButton() method in the Portfolio class which is executed when the user presses the "Buy" button. So, if we get any exceptions, they will be caught and an appropriate message is printed in its message area. Now, if all the fields are valid, and the provided symbol does not exist, then we add that investment's symbol, name, price, quantity and calculate the bookValue by calling the Stock/MutualFund constructor. If the user wants to buy more shares of an existing investment(stock/mutualfund), then we simply calculate the new bookValue and add it to the existing one and update that bookValue  by calling the buy() method from the Stock/MutualFund class. The panel for the "Buy" option also has a "Reset" button which will clear all the values in the text fields.


2. For the sell option, the user has enter the symbol, quantity and price in their respective text fields. If any single field is left blank, then we print an appropriate message in its message area. We first, check if the shares of the investment, the user wants to sell even exists and so if the entered symbol does not exist in the Portfolio, then their request is rejected and we do not check for the remaining text fields. Next, we check if the entered price and quantity are valid, and this check is done using two methods quantityException() and priceException() in the Portfolio class since we need the quantity for comparison with the available quantity and so we cannot use its setter method yet. In these methods, we first check if they consist of digits, otherwise we throw an IllegalArgumentException. If it consists of digits but the value is less than 1, even then an IllegalArgumentException will be thrown. These exceptions will be caught by the sellButton() method in the Portfolio class which is executed when the user presses the "Sell" button. So, if we get any exceptions, they will be caught and an appropriate message is printed in its message area. Now, if all the fields are valid, and the provided symbol exists,  then we have 3 possible cases: (a) If the quantity that the user wants to sell is the same as the available quantity, then that means we will sell the entire investment and remove it from its respective ArrayList using the remove() method(abstract) from the Stock/MutualFund class, (b) If the quantity that the user wants to sell is more than the available quantity, then we print a message and reject their request, (c) If the quantity that the user wants to sell is less than the available quantity, then we simply sell that many shares of that investment at the given price and update the price, bookValue and reduce the quantity of that investment using the sell() method(abstract) from the Stock/MutualFund class. If the user sells partial/all shares of an investment then we will also print a message saying that they have sold "x" number of shares for "y" investment(payment) and also print the total gain they accumulated(calculated by: payment-bookValue) in the message area.


3. For the update option, the user will be presented with three buttons: Prev, Next and Save and three text fields for Symbol, Name and Price out of which Symbol and Name are not editable. Initially, all the fields will be empty and the Prev button will be disabled and the user has to press the Next button to start seeing each investment and when the user is viewing the first investment, the Prev button will also be disabled. When the user is seeing the last investment, the Next button will be disabled, other than that the user can press either Prev or Next button to display each investment and update its price.  So, we will first check if the price field is not empty and then call the setPrice() method in the Investment class which also checks if the value consists of digits, otherwise we throw an IllegalArgumentException. If it consists of digits but the value is less than 1, even then an IllegalArgumentException will be thrown. This exception will be caught by the saveButton() method in the Portfolio class which is called when the user selected the "Update" option from the main menu and an appropriate message is printed in its message area. If the entered price is valid, then the price for that investment is updated and the updated information of that investment is displayed in the message area.


4. For the getGain option, there is only one text field called "Total gain" which cannot be edited by the user. So when the user selects the "getGain  option from the drop-down menu, the getGainMethod() method is called in Portfolio class which returns the total gain (calculated by: payment-bookValue) of the portfolio and displays that in the "Total gain" field and also displays the individual gain for each investment in its message area. 

5. For the search command, there are 4 text fields: symbol,name(keywords), low and high price. Here, we first check if the symbol exists in the Portfolio, if not we print a message in the message area. Next, we validate the entered price range  such that the first number is not greater than the second number (ex: 100-50 is invalid) and make sure that the low and high price fields do not consist of non-digit characters and if they consist of digit characters, that value is more than 1, If any condition is failed, then an IllegalArguementException will be thrown by validQuantity() method in Portfolio class. This exception will be caught by the searchButton() method in the Portfolio class which is called when the user selected the "Search" option from the main menu and an appropriate message is printed in its message area. We also have a method that returns the index position of a given symbol(symbolExists()) from its respective ArrayList, we also have a method that returns the index position of the keyword(using the HashMap that we are maintaining throughout the entire program) and price range(priceRangeSearch()) that the user enters from its respective ArrayList, but since more than one investment can have the same keyword and price range if we find a keyword/price range, we add it to a new ArrayList. Here, we have 8 cases to consider and in our Portfolio class, we have a method(investmentSearch()) that checks for 7 cases where all three fields are not left empty at the same time and these methods then call the 3 methods described above for symbol, keyword and price range(also in Portfolio class).

(a)If the user leaves all the fields blank, then we simply print all the investments.

(b)If the user gives input for every field, then we will call the 3 methods described above and since only one investment can have a specific symbol, we will only ever get one investment that matches with the criteria specified by the user. We will then check if the index position of the keyWord and priceRange matches with the symbol's index position, if this is true then we simply add it(index position) to an ArrayList which will be returned and the investment at that index position will be displayed in the message area.

(c)If the user enters only the symbol, then all investments will be checked for that symbol and its index position will be returned to main() and the investment at that index position will be printed(We can only ever get one investment). If the user enters only the keyword, then all investments will be checked for that keyword and since multiple investments can have the same keyword, the index position of those investments will be added to an arraylist which will be returned to main() and the investment/s at that index position will be printed. Lastly, if the user enters only the price range, then all investments will be checked for that price range and since multiple investments can have the same price range, the index position of those investments will be added to an arraylist which will be returned and the investment/s at that index position will be displayed in the message area.

(d) If the user enters only the symbol and keyword, then all the investments will be checked for that symbol and keyword. Since a symbol is unique we will only ever get a single investment but since multiple investments can have the same keyword, the index position of those investments will be added to an ArrayList. Then we check if the index position of that symbol is present in the ArrayList which contains the indices of the investments where the keyword is present, if this is so, we simply return it to main() and the investment at that index position will be printed. If the user enters only the symbol and price range, then all the investments will be checked for that symbol and price range. Since a symbol is unique we will only ever get a single value but since multiple investments can have the same price range, the index position of those investments will be added to an arraylist. Then we check if the index position of that symbol is present in the ArrayList which contains the indices of the price range where the keyword is present, if this is so, we simply return it to main() and the investment at that index position will be printed. Lastly, If the user enters only the price range and keyword, then all the investments will be checked for that price range and keyword. Here, since multiple investments can have the same keyword and price range, the index position of those investments will be added to two separate ArrayLists. Then we combine those two ArrayLists and check that if an element is present two times which means that price range and keyword are matched with an investment, then we add that index position to a separate ArrayList and returned and the investment(s) at that index position will be displayed in the message area.

Note: If the given input by the user does not match any investment, then an empty ArrayList is returned which means that no investments match the criteria specified by the user and we print this in the message area.

6. For the "quit" command, if the user selects this option from the drop-down menu, then we will terminate the program and save all the changes made to the Portfolio in a text file.
